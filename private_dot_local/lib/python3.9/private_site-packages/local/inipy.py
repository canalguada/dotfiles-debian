#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import configparser
import re

def lower(s):
    return s.lower().strip(' "')

class SimpleIniParser:
    def __init__(self, path=None, encoding='utf-8'):
        self.path = path
        self.parser = configparser.RawConfigParser(allow_no_value=True)
        self.parser.optionxform = lambda option: option

        if path:
            self.parser.read_file(open(self.path, encoding=encoding))

    def load(self, path, encoding='utf-8'):
        self.path = path
        self.parser.read_file(open(self.path, encoding=encoding))

    def clear(self):
        self.parser.clear()
        # for s in self.parser.sections():
        #     self.parser.remove_section(s)
        # if self.parser.options('DEFAULT'):
        #     for k in self.parser.options('DEFAULT'):
        #         self.parser.remove_option('DEFAULT', k)

    def list_all_keys(self):
        return ['%s:%s' % (s, k)
                for s in self.parser.sections()
                for k in self.parser.options(s)]

    def list_sections(self):
        return self.parser.sections()

    def has_section(self, section):
        return self.parser.has_section(section)

    def list_keys(self, section):
        return self.parser.options(section)

    def egrep(self, pattern):
        # grepper = re.compile(pattern)
        # return list(filter(grepper.search, self.list_all_keys()))
        return [k for k in self.list_all_keys()
                if re.search(pattern, k)]

    def egrep_value(self, pattern):
        # grepper = re.compile(pattern)
        # return ["%s:%s" %  (s, k)
                # for s in self.parser.sections()
                # for k in self.parser.options(s)
                # if grepper.search(self.parser.get(s, k))]
        return ["%s:%s" % (s, k)
                for s in self.parser.sections()
                for k in self.parser.options(s)
                if re.search(pattern, self.parser.get(s, k))]

    def exists(self, key):
        s, k = key.split(':')
        try:
            return self.parser.has_option(s, k)
        except configparser.NoSectionError:
            return False

    def value(self, key):
        s, k = key.split(':')
        try:
            return self.parser.get(s, k)
        except configparser.NoSectionError:
            return ''
        except configparser.NoOptionError:
            return ''

    def print(self, key):
        print(self.value(key))

    def print_format(self, format_string, keys):
        values = list(map(self.value, keys))
        print(format_string.format(*values))

def main():

    def parser_init():
        parser.add_argument('--version', action='version',
                            version='%(prog)s 0.0.1')
        parser.add_argument('inifile', nargs='+')
        # parser.add_argument('infile', nargs='?',
        #                     type=argparse.FileType('r'), default=sys.stdin)
        # parser.add_argument('outfile', nargs='?',
        #                     type=argparse.FileType('w'), default=sys.stdout)

        actions = parser.add_mutually_exclusive_group(required=False)
        actions.add_argument('-a', '--list-all-keys', action="store_true",
                             help='List all keys')
        actions.add_argument('-s', '--list-sections', action="store_true",
                             help='List INI sections')
        actions.add_argument('-k', '--list-keys',
                             help='List keys in given section')

        actions.add_argument('-G', '--egrep',
                             help='List all keys matching the given '
                                  'extended regex')
        actions.add_argument('-V', '--egrep-value',
                             help='List all keys the value of which matches '
                                  'the given extended regex')

        actions.add_argument('-e', '--exists',
                             help='Test if the value at given key exists, '
                                  'return 0 if it does, otherwise return 2')
        actions.add_argument('-p', '--print',
                             help='Print the value associated with given key '
                                  'return 0, otherwise print nothing and '
                                  'return 2')
        actions.add_argument('-P', dest='special', action="store_true",
                             help='Format output')

        pretty = parser.add_argument_group(
            'Format output',
            'Print list of values for given keys in specified format '
            'and return 0. When there is no value associated with one key, '
            'print nothing silently but return 2.')
        pretty.add_argument('--format', help='Format. Ex : "{0}:{1} - {0}"')
        pretty.add_argument('--keys', nargs='+',
                            help='Sequence of keys. Ex : "Desktop Entry:Name" '
                                 '"Desktop Entry:Exec"')

        parser.set_defaults(
            list_all_keys=False, list_sections=False, special=False)

    parser = argparse.ArgumentParser(prog='inipy')
    parser_init()

    args = parser.parse_args()

    ini = SimpleIniParser()
    files = args.inifile
    for fname in files:
        ini.load(fname)

        # Format output
        if args.special:
            required = []
            if not args.format:
                required.append('--format')
            if not args.keys:
                required.append('--keys')
            if required:
                parser.error(
                    'the following arguments are required : '
                    '%s' % ', '.join(required))
            else:
                ini.print_format(args.format, args.keys)

        # List all keys : -a, --list-all-keys
        elif args.list_all_keys:
            for k in ini.list_all_keys():
                print(k)

        # List all sections : -s, --list-sections
        elif args.list_sections:
            for s in ini.list_sections():
                print(s)

        # List keys for section : -k, --list-keys
        elif args.list_keys:
            if ini.has_section(args.list_keys):
                for k in ini.list_keys(args.list_keys):
                    print(k)

        # Value exists : -e, --exists
        elif args.exists:
            if ini.exists(args.exists):
                parser.exit()
            else:
                parser.exit(status=2)

        # Print value if exists : -p, --print
        elif args.print:
            res = ini.value(args.print)
            if res:
                print(res)
                parser.exit()
            else:
                parser.exit(status=2)

        # List keys matching regex : -G, --egrep
        elif args.egrep:
            for k in ini.egrep(args.egrep):
                print(k)

        # List keys for value matching regex : -V, --egrep-value
        elif args.egrep_value:
            for k in ini.egrep_value(args.egrep_value):
                print(k)

        else:
            parser.error('Unknow error.')
        pass

if __name__ == "__main__":
    main()

# vim: set ai ts=4 sw=4 tw=79:
